---
title: "A decade of research and development on program animation: The Jeliot experience"
date: 2011-12-10 13:08:30
year: 2011
original: nwit
---
<p>Mordechai Ben-Ari and Roman Bednarik and Ronit Ben-Bassat Levy and Gil Ebel and Andr&eacute;s Moreno and Niko Myller and Erkki Sutinen: "A decade of research and development on program animation: The Jeliot experience". <cite>Journal of Visual Languages &amp; Computing</cite>, 22(5), 2011.</p>
<blockquote><em>Jeliot is a program animation system for teaching and learning elementary programming that has been developed over the past decade, building on the Eliot animation system developed several years before. Extensive pedagogical research has been done on various aspects of the use of Jeliot including improvements in learning, effects on attention, and acceptance by teachers. This paper surveys this research and development, and summarizes the experience and the lessons learned.</em></blockquote>
<p>Like our two <a href="http://www.neverworkintheory.org/?p=230">previous</a> <a href="http://www.neverworkintheory.org/?p=233">papers</a>, this one is about software engineering education rather than software engineering per se, but (a) we're unlikely to improve the latter until we start getting the former right, and (b) education research has always had a strongly empirical flavor, which people studying "grown up" programmers could learn a lot from. What makes this paper interesting for me is that it describes how a specific research program has evolved over more than ten years. Ideas are turned into tools; how people use those tools, and what impact they have, are studied in situ; those studies produce new insights, which are turned into a new generation of tools, and the cycle repeats. Along the way, the researchers evolve as well: they learn how to ask more penetrating questions, and (hopefully) how to iterate more rapidly. Jonathan Weiner's book <a href="http://www.amazon.com/Time-Love-Memory-Biologist-Behavior/dp/0679444351"><cite>Time, Love, Memory</cite></a> does a great job of describing this process at greater length in genetics; young researchers (and those of us who are not so young) can learn a lot about our craft from reading both.</p>
<p>So what does this paper actually cover? It opens with an eight-paragraph summary of program visualization&mdash;tools and methods to draw pictures of the states of programs as they execute&mdash;followed by a brief discussion of the difference between <em>program</em> animation and <em>algorithm</em> animation. Section 3 then summarizes the evolution of their software testbed, while Section 4 shows readers what it looks like now. Sections 5-10 are the meat of the paper: what do users learn, and what effect does program visualization have on attention (both in the classroom as a whole and at the individual level), on teachers, and on collaboration. Section 11, an in-depth summary of lessons learned. In a way, it's the whole point of the paper, and everything that comes before it is scene-setting. I wish there were more summaries and retrospectives like this, since every shared insight can save other designers or researchers months of wasted effort going down blind alleys.</p>
