<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design in Python: Matching Patterns</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design in Python</a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../tester/">
      A Testing Framework
    </a>
  </li>
  
  <li>
    <a href="../interpreter/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../backup/">
      Versioned File Backups
    </a>
  </li>
  
  <li>
    <a href="../cache/">
      A File Cache
    </a>
  </li>
  
  <li>
    <a href="../dataframe/">
      A Dataframe
    </a>
  </li>
  
  <li>
    <a href="../persistence/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Storage
    </a>
  </li>
  
  <li>
    <a href="../builder/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../templating/">
      A Static Site Generator
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../editor/">
      An Editor
    </a>
  </li>
  
  <li>
    <a href="../server/">
      A Web Server
    </a>
  </li>
  
  <li>
    <a href="../packman/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../matching/">
      <strong>Matching Patterns</strong>
    </a>
  </li>
  
  <li>
    <a href="../parser/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../linter/">
      A Style Checker
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../slides/">
      Slides
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 15: Matching Patterns</h1>


          
            
<div class="draft">
  <p>DRAFT</p>
</div>


            
  

  

  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Use regular expressions to match patterns in text and extract data.</li>
  
  <li markdown="1">Use inheritance to make matchers composable and extensible.</li>
  
  <li markdown="1">Objects can delegate work to other objects using the Chain of Responsibility pattern.</li>
  
  </ul>
  

  

  

  

  


            
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#base_class" markdown="1">base class</a>, <a class="gl-ref" href="../glossary/#chain_of_responsibility_pattern" markdown="1">Chain of Responsibility pattern</a>, <a class="gl-ref" href="../glossary/#eager_matching" markdown="1">eager matching</a>, <a class="gl-ref" href="../glossary/#greedy_algorithm" markdown="1">greedy algorithm</a>, <a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy matching</a>, <a class="gl-ref" href="../glossary/#polymorphism" markdown="1">polymorphism</a>
</p>


            <div class="page-toc"></div>
            <p>Sooner or later everyone needs to scrape data out of text files.
Regular expressions are the best tool for the job,
so this chapter explores how they work by building a simple but extensible pattern matcher.
Our approach is inspired by <span class="ix-entry" ix-key="Kernighan, Brian" markdown="1">Brian Kernighan&rsquo;s</span> entry
in <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Oram2007">Oram2007</a>]</span>.</p>
<h2 id="matching-simple">Section 15.1: Simple Patterns</h2>
<p>Our matcher will initially handle just the five cases shown in
<a class="tbl-ref" href="../matching/#pattern-matching-cases">Table 15.1</a>.
These cases are a small subset of what Python&rsquo;s <code>re</code> module provides,
but as <span class="ix-entry" ix-key="Kernighan, Brian" markdown="1">Kernighan</span> wrote,
&ldquo;This is quite a useful class;
in my own experience of using regular expressions on a day-to-day basis,
it easily accounts for 95 percent of all instances.&rdquo;</p>
<div class="table"><table id="pattern-matching-cases"><caption>Table 15.1: Pattern matching cases</caption>
<thead>
<tr>
<th>Meaning</th>
<th>Character</th>
</tr>
</thead>
<tbody>
<tr>
<td>Any literal character <em>c</em></td>
<td><em>c</em></td>
</tr>
<tr>
<td>Any single character</td>
<td>.</td>
</tr>
<tr>
<td>Beginning of input</td>
<td>^</td>
</tr>
<tr>
<td>End of input</td>
<td>$</td>
</tr>
<tr>
<td>Zero or more of something</td>
<td>*</td>
</tr>
</tbody>
</table>
</div>
<p>Matching is conceptually simple.
If the first element of the pattern matches where we are,
we see if the rest of the pattern matches what&rsquo;s left;
otherwise,
we see if the the pattern will match further along.</p>
<p>The function <code>match</code> handles the special case of <code>^</code> at the start of a pattern.
It then tries the pattern against each successive substring of the target string
until it finds a match or runs out of characters:</p>
<div class="code-sample lang-py" title="simple_regexp.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="c1"># Empty pattern matches any string.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Start of string.</span>
    <span class="k">if</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">match_here</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Need &#39;do-while&#39; to handle zero characters matching.</span>
    <span class="n">i_text</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">match_here</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">i_text</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">i_text</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i_text</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">break</span>

    <span class="c1"># Nothing worked.</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
</div>
<p><code>match_here</code> does the matching and recursing:</p>
<div class="code-sample lang-py" title="simple_regexp.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">match_here</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">i_pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">i_text</span><span class="p">):</span>
    <span class="c1"># No more pattern to match.</span>
    <span class="k">if</span> <span class="n">i_pattern</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># &quot;$&quot; at end of pattern matches end of text.</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">i_pattern</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">i_pattern</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">i_text</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># &quot;*&quot; following current character means match many.</span>
    <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">-</span> <span class="n">i_pattern</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">i_pattern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">):</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i_text</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i_text</span><span class="p">]</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i_pattern</span><span class="p">]):</span>
            <span class="n">i_text</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">match_here</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">i_pattern</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">i_text</span><span class="p">)</span>

    <span class="c1"># There is no more text to match.</span>
    <span class="k">if</span> <span class="n">i_text</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Match a single character.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">i_pattern</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">i_pattern</span><span class="p">]</span> <span class="o">==</span> <span class="n">text</span><span class="p">[</span><span class="n">i_text</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">match_here</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">i_pattern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">i_text</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Nothing worked.</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
</div>
<p>We use a table of test cases and expected results to test it:</p>
<div class="code-sample lang-py" title="test_simple_regexp.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">simple_regexp</span> <span class="kn">import</span> <span class="n">match</span>

<span class="k">def</span> <span class="nf">test_simple_regexp</span><span class="p">():</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;^b&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;a$&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;a$&quot;</span><span class="p">,</span> <span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;a*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;a*&quot;</span><span class="p">,</span> <span class="s2">&quot;baac&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;ac&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;abbbc&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;abxc&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">regexp</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="n">regexp</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">actual</span> <span class="o">==</span> <span class="n">expected</span>
</code></pre></div>
</div>
<p>This program seems to work,
but it actually contains an error that we will correct in the exercises.
(Think about what happens if we match the pattern <code>a*ab</code> against the string <code>'aab'</code>.)
It is also hard to extend:
<code>match_here</code> is already very complicated,
and handling parentheses in patterns like <code>a(bc)*d</code> will make it more complicated still.</p>
<h2 id="matching-responsible">Section 15.2: Matching Responsibly</h2>
<p>Instead of packing all our code into one function,
we can implement each kind of match separately.
Doing this makes it easier to add more matchers:
we just define something we can mix in with the matchers we already have.</p>
<p>Rather than matching text immediately,
though,
we will create objects that know how to do matches
so that we can build a complex matcher once and re-use it many times.
This is a common practice in text processing:
if we want to apply a regular expression to each line in a large set of files,
recycling matchers makes programs more efficient.</p>
<p>Each matching object has a method
that takes the target string and the index to start matching at as inputs.
Its output is the index to continue matching at
or <code>None</code> indicating that matching failed
(<a class="fig-ref" href="../matching/#matching-direct">Figure 15.1</a>).</p>
<figure id="matching-direct">
  <img src="./matching_direct.svg" alt="Implementing regular expressions with objects"/>
  <figcaption markdown="1">Figure 15.1: Using nested objects to match regular expressions.</figcaption>
</figure>

<p>Our matching classes will be:</p>
<ul>
<li><code>Alt</code> (for &ldquo;alternative&rdquo;) to match either of two possibilities;</li>
<li><code>Any</code> to match any single character;</li>
<li><code>End</code> to match the end of a string;</li>
<li><code>Lit</code> to match a literal character;</li>
<li><code>Seq</code> to match a sequence of patterns; and</li>
<li><code>Start</code> to match the start of a string.</li>
</ul>
<p>Our first step is to write test cases.
Instead of looping over them ourselves
we will use <code>pytest</code>&lsquo;s <code>parametrize</code> decorator:</p>
<div class="code-sample lang-py" title="test_direct.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">direct</span> <span class="kn">import</span> <span class="n">Alt</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">End</span><span class="p">,</span> <span class="n">Lit</span><span class="p">,</span> <span class="n">Seq</span><span class="p">,</span> <span class="n">Start</span>

<span class="n">TESTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)],</span>
    <span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)],</span>
    <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)],</span>
    <span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)],</span>
    <span class="p">[</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)],</span>
    <span class="p">[</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Start</span><span class="p">(),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;^b&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Start</span><span class="p">(),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;a$&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">End</span><span class="p">())],</span>
    <span class="p">[</span><span class="s2">&quot;a$&quot;</span><span class="p">,</span> <span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">End</span><span class="p">())],</span>
    <span class="p">[</span><span class="s2">&quot;a*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Any</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)],</span>
    <span class="p">[</span><span class="s2">&quot;a*&quot;</span><span class="p">,</span> <span class="s2">&quot;baac&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Any</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)],</span>
    <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;ac&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Any</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Any</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;abbbc&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Any</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;ab*c&quot;</span><span class="p">,</span> <span class="s2">&quot;abxc&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Any</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;ab|cd&quot;</span><span class="p">,</span> <span class="s2">&quot;xaby&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Alt</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;cd&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;ab|cd&quot;</span><span class="p">,</span> <span class="s2">&quot;acdc&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Alt</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;cd&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;a(b|c)d&quot;</span><span class="p">,</span> <span class="s2">&quot;xabdy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Alt</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))],</span>
    <span class="p">[</span><span class="s2">&quot;a(b|c)d&quot;</span><span class="p">,</span> <span class="s2">&quot;xabady&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Seq</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Alt</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))],</span>
<span class="p">]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="s2">&quot;params&quot;</span><span class="p">,</span> <span class="n">TESTS</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_direct</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">params</span>
    <span class="n">actual</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">actual</span> <span class="o">==</span> <span class="n">expected</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p class="continue">Notice that we have provided a message with the <code>assert</code> in our test
so that we can tell which tests failed (if any).</p>
<p>Next,
we define a <a class="gl-ref" href="../glossary/#base_class" markdown="1">base class</a> that all matchers will inherit from.
This class contains the <code>match</code> method that users will call
so that we can start matching right away
no matter what kind of matcher we have at the top level of our pattern:</p>
<div class="code-sample lang-py" title="direct.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">MatchBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p>We can now define each matching class,
like this one for literal characters:</p>
<div class="code-sample lang-py" title="direct.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Lit</span><span class="p">(</span><span class="n">MatchBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chars</span> <span class="o">=</span> <span class="n">chars</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">nextIndex</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nextIndex</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">nextIndex</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">nextIndex</span>
</code></pre></div>
</div>
<p class="continue">Our tests now run, but most of them fail:
&ldquo;most&rdquo; because we expect that some patterns <em>won&rsquo;t</em> match the text provided.
This output tells us how much work we have left to do:
when all of these tests pass,
we&rsquo;re finished.</p>
<div class="code-sample lang-out" title="test_direct.out">
<div class="highlight"><pre><span></span><code>FAILED test_direct.py::test_direct[params1] - AssertionError: b vs a
FAILED test_direct.py::test_direct[params3] - AssertionError: b vs ab
FAILED test_direct.py::test_direct[params4] - AssertionError: ab vs ab
FAILED test_direct.py::test_direct[params5] - AssertionError: ba vs ab
FAILED test_direct.py::test_direct[params6] - AssertionError: ab vs ba
FAILED test_direct.py::test_direct[params7] - AssertionError: ^a vs ab
FAILED test_direct.py::test_direct[params8] - AssertionError: ^b vs ab
FAILED test_direct.py::test_direct[params9] - AssertionError: a$ vs ab
FAILED test_direct.py::test_direct[params10] - AssertionError: a$ vs ba
FAILED test_direct.py::test_direct[params11] - AssertionError: a* vs
FAILED test_direct.py::test_direct[params12] - AssertionError: a* vs baac
FAILED test_direct.py::test_direct[params13] - AssertionError: ab*c vs ac
FAILED test_direct.py::test_direct[params14] - AssertionError: ab*c vs abc
FAILED test_direct.py::test_direct[params15] - AssertionError: ab*c vs abbbc
FAILED test_direct.py::test_direct[params16] - AssertionError: ab*c vs abxc
FAILED test_direct.py::test_direct[params17] - AssertionError: ab|cd vs xaby
FAILED test_direct.py::test_direct[params18] - AssertionError: ab|cd vs acdc
FAILED test_direct.py::test_direct[params19] - AssertionError: a(b|c)d vs xabdy
FAILED test_direct.py::test_direct[params20] - AssertionError: a(b|c)d vs xabady
</code></pre></div>
</div>
<p>What about repetition?
It can just apply a pattern over and over to consume as many matches as possible—or can it?
Suppose we have the pattern <code>a*ab</code>.
This ought to match the text <code>"ab"</code>, but will it?
<code>*</code> is <span class="ix-entry" ix-key="greedy algorithm;algorithm!greedy" markdown="1"><a class="gl-ref" href="../glossary/#greedy_algorithm" markdown="1">greedy</a></span>:
it matches as much as it can.
(This is also called <span class="ix-entry" ix-key="eager matching;matching!eager" markdown="1"><a class="gl-ref" href="../glossary/#eager_matching" markdown="1">eager matching</a></span>.)
As a result,
<code>a*</code> will match the leading <code>"a"</code>, leaving nothing for the literal <code>a</code> to match
(<a class="fig-ref" href="../matching/#matching-greedy">Figure 15.2</a>).
Our current implementation doesn&rsquo;t give us a way to try other possible matches when this happens.</p>
<figure id="matching-greedy">
  <img src="./matching_greedy.svg" alt="Overly-greedy matching fails"/>
  <figcaption markdown="1">Figure 15.2: Why overly greedy matching doesn&rsquo;t work.</figcaption>
</figure>

<h2 id="matching-alternative">Section 15.3: An Alternative Design</h2>
<p>Let&rsquo;s re-think our design
and have each matcher take its own arguments and a <code>rest</code> parameter containing the rest of the matchers
(<a class="fig-ref" href="../matching/#matching-rest">Figure 15.3</a>).
(We will provide a default of <code>None</code> in the creation function
so we don&rsquo;t have to type <code>None</code> over and over again.)
Each matcher will try each of its possibilities and then see if the rest will also match:</p>
<div class="code-sample lang-py" title="re_base.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">RegexBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;derived classes must override &#39;_match&#39;&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="matching-rest">
  <img src="./matching_rest.svg" alt="Matching using a chain of responsibility"/>
  <figcaption markdown="1">Figure 15.3: Using Chain of Responsibility for matching.</figcaption>
</figure>

<p>This design means we can get rid of <code>Seq</code>,
but it does mean our expressions become deeply nested.
For example, the expression to match <code>ab*c</code> is:</p>
<div class="highlight"><pre><span></span><code><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)))</span>
</code></pre></div>
<p>Here&rsquo;s how this strategy works for matching a literal expression:</p>
<div class="code-sample lang-py" title="re_lit.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">re_base</span> <span class="kn">import</span> <span class="n">RegexBase</span>

<span class="k">class</span> <span class="nc">Lit</span><span class="p">(</span><span class="n">RegexBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chars</span> <span class="o">=</span> <span class="n">chars</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="n">next_index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_index</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">next_index</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">next_index</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The <code>_match</code> method checks whether all of the pattern matches the target text
starting at the current location.
If so,
it checks whether the rest of the overall pattern matches what&rsquo;s left.
Matching the start <code>^</code> and end <code>$</code> anchors is just as straightforward:</p>
<div class="code-sample lang-py" title="re_start.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">re_base</span> <span class="kn">import</span> <span class="n">RegexBase</span>

<span class="k">class</span> <span class="nc">Start</span><span class="p">(</span><span class="n">RegexBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">and:</p>
<div class="code-sample lang-py" title="re_end.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">re_base</span> <span class="kn">import</span> <span class="n">RegexBase</span>

<span class="k">class</span> <span class="nc">End</span><span class="p">(</span><span class="n">RegexBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Matching either/or is done by trying the first pattern and the rest,
and if that fails,
trying the second pattern and the rest:</p>
<div class="code-sample lang-py" title="re_alt.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">re_base</span> <span class="kn">import</span> <span class="n">RegexBase</span>

<span class="k">class</span> <span class="nc">Alt</span><span class="p">(</span><span class="n">RegexBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="n">after_pat</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">after_pat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">after_pat</span>
                <span class="n">after_rest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">after_pat</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">after_rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">after_rest</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p>To match a repetition,
we figure out the maximum number of matches that might be left,
then count down until something succeeds.
(We start with the maximum because matching is supposed to be greedy.)
Each non-empty repetition matches at least one character,
so the number of remaining characters is the maximum number of matches worth trying.</p>
<div class="code-sample lang-py" title="re_any.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">re_base</span> <span class="kn">import</span> <span class="n">RegexBase</span>

<span class="k">class</span> <span class="nc">Any</span><span class="p">(</span><span class="n">RegexBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">child</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="n">max_possible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_possible</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">after_many</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_many</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">after_many</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">after_many</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_match_many</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start</span>
</code></pre></div>
</div>
<p>With these classes in place,
our tests all pass:</p>
<div class="code-sample lang-out" title="test_re.out">
<div class="highlight"><pre><span></span><code>============================= test session starts ==============================
platform darwin -- Python 3.10.6, pytest-7.1.2, pluggy-1.0.0
rootdir: /Users/gregwilson/sdxpy/en/src/matching
plugins: pyfakefs-4.6.3
collected 21 items

test_re.py .....................                                         [100%]

============================== 21 passed in 0.02s ==============================
</code></pre></div>
</div>
<p>The most important thing about this design is how extensible it is.
If we want to add other kinds of matching,
all we have to do is add more classes.
That extensibility comes from the lack of centralized decision-making,
which in turn comes from our use of <span class="ix-entry" ix-key="polymorphism" markdown="1"><a class="gl-ref" href="../glossary/#polymorphism" markdown="1">polymorphism</a></span>
and the <span class="ix-entry" ix-key="Chain of Responsibility pattern;design pattern!Chain of Responsibility" markdown="1"><a class="gl-ref" href="../glossary/#chain_of_responsibility_pattern" markdown="1">Chain of Responsibility</a></span> design pattern.
Each component does its part and asks something else to handle the remaining work;
so long as each component takes the same inputs,
we can put them together however we want.</p>
<h2 id="matching-summary">Section 15.4: Summary</h2>
<figure id="matching-concept-map">
  <img src="./matching_concept_map.svg" alt="Concept map for regular expression matching"/>
  <figcaption markdown="1">Figure 15.4: Regular expression matching concept map.</figcaption>
</figure>

<h2 id="matching-exercises">Section 15.5: Exercises</h2>
<h3 class="exercise">Find and fix the error</h3>
<p>The first regular expression matcher contains an error:
the pattern <code>'a*ab'</code> should match the string <code>'aab'</code> but doesn&rsquo;t.
Figure out why it fails and fix it.</p>
<h3 class="exercise">One more than length</h3>
<p>The main loop in <code>RegexBase.match</code> has <code>+1</code> inside the <code>range</code> call.
Which test(s) break when this is removed and why?</p>
<h3 class="exercise">Find all</h3>
<p>Modify the regular expression matcher to return <em>all</em> matches rather than just the first one.</p>
<h3 class="exercise">Find one or more</h3>
<p>Extend the regular expression matcher to support <code>+</code>, meaning &ldquo;one or more&rdquo;.</p>
<h3 class="exercise">Match sets of characters</h3>
<p>Add a new regular expression matching class that matches any character from a set,
so that <code>Charset('aeiou')</code> matches any lower-case vowel.</p>
<h3 class="exercise">Make repetition more efficient</h3>
<p>Rewrite <code>Any</code> so that it does not repeatedly re-match text.</p>
<h3 class="exercise">Lazy matching</h3>
<p>The regular expressions we have seen so far are <a class="gl-ref" href="../glossary/#eager_matching" markdown="1">eager</a>:
they match as much as they can, as early as they can.
An alternative is <span class="ix-entry" ix-key="lazy algorithm;algorithm!lazy" markdown="1"><a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy matching</a></span>,
in which expressions match as little as they need to.
For example,
given the string <code>"ab"</code>,
an eager match with the expression <code>ab*</code> will match both letters
(because <code>b*</code> matches a &lsquo;b&rsquo; if one is available)
but a lazy match will only match the first letter
(because <code>b*</code> can match no letters at all).
Implement lazy matching for the <code>*</code> operator.</p>
<h3 class="exercise">Optional matching</h3>
<p>The <code>?</code> operator means &ldquo;optional&rdquo;,
so that <code>a?</code> matches either zero or one occurrences of the letter &lsquo;a&rsquo;.
Implement this operator.</p>
<h3 class="exercise">Performance</h3>
<p>Our matcher is slower than the one in Python&rsquo;s <code>re</code> module.</p>
<ol>
<li>
<p>Write some tests to find out how much slower.</p>
</li>
<li>
<p>How does your choice of test cases affect your answer?</p>
</li>
</ol>
<h3 class="exercise">DOM Selectors</h3>
<p>Write a recursive function that finds nodes in a <span class="ix-entry" ix-key="DOM" markdown="1">DOM</span> tree
so that (for example) <code>match(dom, ['div', 'p', 'a'])</code>
finds all of the hyperlinks (with tag <code>a</code>)
in paragraphs (with tag <code>p</code>)
in divs (with tag <code>div</code>).</p>
          
        </main>
      </div>
    </div>
  </body>
</html>
