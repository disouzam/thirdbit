<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design in Python: An Interpreter</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design in Python</a>
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../tester/">
      A Testing Framework
    </a>
  </li>
  
  <li>
    <a href="../interpreter/">
      <strong>An Interpreter</strong>
    </a>
  </li>
  
  <li>
    <a href="../backup/">
      Versioned File Backups
    </a>
  </li>
  
  <li>
    <a href="../persistence/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Storage
    </a>
  </li>
  
  <li>
    <a href="../builder/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../templating/">
      A Static Site Generator
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../server/">
      A Web Server
    </a>
  </li>
  
  <li>
    <a href="../matching/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parser/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../linter/">
      A Style Checker
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../dataframe/">
      A Dataframe
    </a>
  </li>
  
  <li class="todo">
    <a href="../pipeline/">
      A Pipeline Runner
    </a>
  </li>
  
  <li class="todo">
    <a href="../cache/">
      A File Cache
    </a>
  </li>
  
  <li class="todo">
    <a href="../database/">
      A Database
    </a>
  </li>
  
  <li class="todo">
    <a href="../packman/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 3: An Interpreter</h1>


          
            
  

  
  <ul class="syllabus">
  
  <li markdown="1">Compilers and interpreters are just programs.</li>
  
  <li markdown="1">Basic arithmetic operations are just functions that have special notation.</li>
  
  <li markdown="1">Programs can be represented as trees, which can be stored as nested lists.</li>
  
  <li markdown="1">Interpreters recurisvely dispatch operations to functions that implement low-level details.</li>
  
  <li markdown="1">Programs store variables in stacked dictionaries called environments.</li>
  
  <li markdown="1">One way to evaluate a program's design is to ask how extensible it is.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


            
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#argument" markdown="1">argument</a>, <a class="gl-ref" href="../glossary/#call_stack" markdown="1">call stack</a>, <a class="gl-ref" href="../glossary/#control_flow" markdown="1">control flow</a>, <a class="gl-ref" href="../glossary/#dictionary_comprehension" markdown="1">dictionary comprehension</a>, <a class="gl-ref" href="../glossary/#dispatch" markdown="1">dispatch</a>, <a class="gl-ref" href="../glossary/#dynamic_scoping" markdown="1">dynamic scoping</a>, <a class="gl-ref" href="../glossary/#eager_evaluation" markdown="1">eager evaluation</a>, <a class="gl-ref" href="../glossary/#environment" markdown="1">environment</a>, <a class="gl-ref" href="../glossary/#extensibility" markdown="1">extensibility</a>, <a class="gl-ref" href="../glossary/#introspection" markdown="1">introspection</a>, <a class="gl-ref" href="../glossary/#json" markdown="1">JavaScript Object Notation</a>, <a class="gl-ref" href="../glossary/#lazy_evaluation" markdown="1">lazy evaluation</a>, <a class="gl-ref" href="../glossary/#lexical_scoping" markdown="1">lexical scoping</a>, <a class="gl-ref" href="../glossary/#parameter" markdown="1">parameter</a>, <a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a>, <a class="gl-ref" href="../glossary/#recursion" markdown="1">recursion</a>, <a class="gl-ref" href="../glossary/#runtime" markdown="1">runtime</a>, <a class="gl-ref" href="../glossary/#signature" markdown="1">signature</a>, <a class="gl-ref" href="../glossary/#stack_frame" markdown="1">stack frame</a>
</p>


            <div class="page-toc"></div>
            <p><a class="x-ref" href="../tester/">Chapter 2</a> introduced the idea that programs are just another kind of data.
Similarly,
the compilers and interpreters that make programs run are just programs themselves.
instead of changing the characters in a block of memory like text editors,
or calculating sums and averages like spreadsheets,
compilers turn text into instructions for interpreters or hardware to run.</p>
<p>Most real programming languages have two parts:
a <a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a> that translates the source code into a data structure in memory,
and a <a class="gl-ref" href="../glossary/#runtime" markdown="1">runtime</a> that executes the instructions in that data structure.
This chapter focuses on the runtime;
<a class="x-ref" href="../parser/">Chapter 12</a> will explore parsing,
whle <a class="x-ref" href="../vm/">Chapter 14</a> will look at more efficient ways to execute instructions.</p>
<h2 id="interpreter-expressions">Section 3.1: Expressions</h2>
<p>Let&rsquo;s start by building something that can evaluate simple expressions
like <code>1+2</code> or <code>abs(-3.5)</code>.
We represent each expression as a list
with the name of the operation as the first item
and the values to be operated on as the other items.
To add 1 and 2 we use:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div>
<p class="continue">and to calculate the absolute value of -3.5 we use:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5</span><span class="p">]</span>
</code></pre></div>
<div class="callout">
<h3>Nothing Special</h3>
<p>We have special symbols for addition, subtraction, and so on for historical reasons,
but our list representation doesn&rsquo;t distinguish between things like <code>+</code> and <code>abs</code>
because it doesn&rsquo;t need to.
If our program is being compiled into low-level instructions for a particular CPU,
it&rsquo;s the compiler&rsquo;s job to decide what can be done directly
and what needs multiple instructions.
For example,
early CPUs didn&rsquo;t have instructions to do division,
while modern CPUs may have instructions to do addition or multiplication
on multiple values at once.</p>
</div>
<p>We can represent more complicated expressions using nested lists.
For example, <code>abs(1+2)</code> is:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</code></pre></div>
<p>The function to add two expressions looks like this:</p>
<div class="code-sample lang-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_add</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
</code></pre></div>
</div>
<p class="continue">Its single parameter is a list containing
the two sub-expressions to be evaluated and added.
After checking that it has the right number of parameters,
it calls the function <code>do</code> <a class="gl-ref" href="../glossary/#recursion" markdown="1">recursively</a> to evaluate those sub-expressions.
(We&rsquo;ve called the function <code>do</code> instead of <code>eval</code>
because Python already has a function called <code>eval</code>.)
Once <code>do_add</code> has two actual values,
it adds them and returns the result
(<a class="fig-ref" href="../interpreter/#interpreter-recursive-evaluation">Figure 3.1</a>)</p>
<figure id="interpreter-recursive-evaluation">
  <img src="./interpreter_recursive_evaluation.svg" alt="Recursive evaluation of an expression tree"/>
  <figcaption markdown="1">Figure 3.1: Recursively evaluation an expression tree.</figcaption>
</figure>

<div class="callout">
<h3>Arguments versus Parameters</h3>
<p>Many programmers use the words <a class="gl-ref" href="../glossary/#argument" markdown="1">argument</a>
and <a class="gl-ref" href="../glossary/#parameter" markdown="1">parameter</a> interchangeably,
but to make our meaning clear,
we call the values passed into a function its arguments
and the names the function uses to refer to them as its parameters.
Put it another way,
parameters are part of the definition
and arguments are given when the function is called.</p>
</div>
<p><code>do_abs</code>, which calculates absolute value,
works the same way.
The only differences are that it expects one value instead of two
and calculates a different return value:</p>
<div class="code-sample lang-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_abs</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</code></pre></div>
</div>
<p>So how does <code>do</code> work?
It starts by checking if its input is an integer.
If so,
it returns that value right away
because integers &ldquo;evaluate&rdquo; to themselves:
no more calculation is needed.
Otherwise,
<code>do</code> checks that its parameter is a list
and then uses the first value in the list
to decide what other function to call.
This process is often called <a class="gl-ref" href="../glossary/#dispatch" markdown="1">dispatch</a>.</p>
<div class="code-sample lang-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="c1"># Integers evaluate to themselves.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Lists trigger function calls.</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_abs</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_add</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown operation </span><span class="si">{</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p>Finally,
the main body of the program reads
the file containing the instructions to execute,
calls <code>do</code>,
and prints the result:</p>
<div class="code-sample lang-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Usage: expr.py filename&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">program</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=&gt; </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>
</div>
<p>Our program is a list of lists (of lists…)
so we can read it as <a class="gl-ref" href="../glossary/#json" markdown="1">JSON</a> using <code>json.load</code>.
If our program file contains:</p>
<div class="code-sample lang-tll" title="expr.tll">
<div class="highlight"><pre><span></span><code>[&quot;add&quot;, [&quot;abs&quot;, -3], 2]
</code></pre></div>
</div>
<p class="continue">then our little interpreter prints:</p>
<div class="code-sample lang-out" title="expr.out">
<div class="highlight"><pre><span></span><code>=&gt; 5
</code></pre></div>
</div>
<p>This is a lot of code to do something that Python already does,
but it shows what Python (and other languages) do themselves.
When we run our little interpreter with:</p>
<div class="highlight"><pre><span></span><code>$ python expr.py expr.tll
</code></pre></div>
<p>Python reads <code>expr.py</code>,
turns it into a data structure with operation identifiers and constants,
then uses those operation identifiers to decide what functions to call.
Those functions are written in C
and have been compiled to machine instructions,
but the cycle of lookup, call, and recurse is exactly the same.</p>
<h2 id="interpreter-variables">Section 3.2: Variables</h2>
<p>Adding up constants is a start,
but our programs will be easier to read with variables
that let us give names to values.
We can add them to our interpreter
by passing around a dictionary containing all the variables seen so far.
Such a dictionary is sometimes called an <a class="gl-ref" href="../glossary/#environment" markdown="1">&ldquo;environment</a>
because it is the setting in which expressions are evaluated;
the dictionaries returned by the <code>globals</code> and <code>locals</code> functions
introduced in <a class="x-ref" href="../tester/">Chapter 2</a> are both environments.</p>
<p>Let&rsquo;s modify <code>do_add</code> and <code>do_abs</code>
to take an environment as an extra parameter and pass it on to <code>do</code> as needed:</p>
<div class="code-sample lang-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_abs</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Looking up variables when we need their values is straightfoward.
We check that we have a variable name and that the name is in the environment,
then return the stored value:</p>
<div class="code-sample lang-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_get</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">env</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown variable </span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</code></pre></div>
</div>
<p>To define a new variable or change an existing one,
we evaluate an expression and store its value in the environment:</p>
<div class="code-sample lang-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">env</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">value</span>
</code></pre></div>
</div>
<p>We need to add one more function to make this all work.
Our programs no longer consist of a single expression;
instead,
we may have several expressions that set variables&rsquo; values
and then use them in calculations.
To handle this,
we add a function <code>do_seq</code> that runs a sequence of expressions one by one.
This function is our first piece of <a class="gl-ref" href="../glossary/#control_flow" markdown="1">control flow</a>:
rather than calculating a value itself,
it controls when and how other expressions are evaluated.
Its implementation is:</p>
<div class="code-sample lang-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_seq</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p>Let&rsquo;s try it out.
Our test program is:</p>
<div class="code-sample lang-tll" title="vars.tll">
<div class="highlight"><pre><span></span><code>[
    &quot;seq&quot;,
    [&quot;set&quot;, &quot;alpha&quot;, 1],
    [&quot;set&quot;, &quot;beta&quot;, 2],
    [&quot;add&quot;, [&quot;get&quot;, &quot;alpha&quot;], [&quot;get&quot;, &quot;beta&quot;]]
]
</code></pre></div>
</div>
<div class="code-sample lang-out" title="vars.out">
<div class="highlight"><pre><span></span><code>=&gt; 3
</code></pre></div>
</div>
<h2 id="interpreter-introspection">Section 3.3: Introspection Again</h2>
<p>Before we add more operations,
let&rsquo;s have a look at the current state of <code>do</code>:</p>
<div class="code-sample lang-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="c1"># Integers evaluate to themselves.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Lists trigger function calls.</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_abs</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_add</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;get&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_get</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;seq&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_seq</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;set&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown operation </span><span class="si">{</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p>The sequence of <code>if</code> statements that decide what function to call
is going to become unreadably long.
Let&rsquo;s use <a class="gl-ref" href="../glossary/#introspection" markdown="1">introspection</a> to create a lookup table instead
by finding and storing every function whose name starts with <code>do_</code>:</p>
<div class="code-sample lang-py" title="vars_reflect.py">
<div class="highlight"><pre><span></span><code><span class="n">OPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;do_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span> <span class="n">func</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;do_&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">Line by line:</p>
<ol>
<li>
<p>We use a <a class="gl-ref" href="../glossary/#dictionary_comprehension" markdown="1">dictionary comprehension</a>
    to create a dictionary in a single statement.</p>
</li>
<li>
<p>We only add functions whose names start with <code>do_</code>.</p>
</li>
<li>
<p>Each key-value pair in the dictionary is the name of an operation
    and the function that implements the operation.
    The operation&rsquo;s name is what comes after <code>do_</code> in the function&rsquo;s name.</p>
</li>
</ol>
<p>With this lookup table in hand,
the code to select and run an operation is:</p>
<div class="code-sample lang-py" title="vars_reflect.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="c1"># Integers evaluate to themselves.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Lists trigger function calls.</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">OPS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown operation </span><span class="si">{</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">OPS</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre></div>
</div>
<p>As with unit test functions in <a class="x-ref" href="../tester/">Chapter 2</a>,
the <code>do_*</code> functions must have exactly the same <a class="gl-ref" href="../glossary/#signature" markdown="1">signature</a>
so that we can all any of them with an environment and a list of arguments
without knowing exactly which function we&rsquo;re calling.
And as with finding tests,
introspection is more reliable than a hand-written lookup table,
but it isn&rsquo;t necessarily easier to understand.
If we write out the lookup table explicitly like this:</p>
<div class="code-sample lang-py" title="vars_table.py">
<div class="highlight"><pre><span></span><code><span class="n">OPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="n">do_abs</span><span class="p">,</span>
    <span class="s2">&quot;add&quot;</span><span class="p">:</span> <span class="n">do_add</span><span class="p">,</span>
    <span class="s2">&quot;get&quot;</span><span class="p">:</span> <span class="n">do_get</span><span class="p">,</span>
    <span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">do_seq</span><span class="p">,</span>
    <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="n">do_set</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">then it&rsquo;s easy to see exactly what operations are available
and what their names are.
If we use introspection,
we have to search through the source file (or possibly several files)
to find all the available operations.</p>
<h2 id="interpreter-statements">Section 3.4: Statements</h2>
<p>Now that we have recursive evaluation, function lookup, and environments,
it&rsquo;s easy to add more features to our little language.
Our goal is to execute this program,
which starts with the number 1 and doubles it four times:</p>
<div class="code-sample lang-tll" title="doubling.tll">
<div class="highlight"><pre><span></span><code>[
    &quot;seq&quot;,
    [&quot;comment&quot;, &quot;Double a number repeatedly&quot;],
    [&quot;set&quot;, &quot;a&quot;, 1],
    [&quot;print&quot;, &quot;initial&quot;, [&quot;get&quot;, &quot;a&quot;]],
    [
        &quot;repeat&quot;,
        4,
        [
            &quot;seq&quot;,
            [&quot;set&quot;, &quot;a&quot;, [&quot;add&quot;, [&quot;get&quot;, &quot;a&quot;], [&quot;get&quot;, &quot;a&quot;]]],
        [&quot;if&quot;,
        [&quot;leq&quot;, [&quot;get&quot;, &quot;a&quot;], 10],
        [&quot;print&quot;, &quot;small&quot;, [&quot;get&quot;, &quot;a&quot;]],
        [&quot;print&quot;, &quot;large&quot;, [&quot;get&quot;, &quot;a&quot;]]
        ]
        ]
    ]
]
</code></pre></div>
</div>
<p>The simplest of the new operations is <code>comment</code>,
which does nothing and returns <code>None</code>:</p>
<div class="code-sample lang-py" title="stmt.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_comment</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ignore instructions.</span>
<span class="sd">    [&quot;comment&quot; &quot;text&quot;] =&gt; None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p>An <code>if</code> statement is a bit more complex.
If its first argument is true it evaluates and returns its second argument
(the &ldquo;if&rdquo; branch).
Otherwise,
it evaluates and returns its second argument (the &ldquo;else&rdquo; branch):</p>
<div class="code-sample lang-py" title="stmt.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_if</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a choice: only one sub-expression is evaluated.</span>
<span class="sd">    [&quot;if&quot; C A B] =&gt; A if C else B</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">choice</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">This is called <a class="gl-ref" href="../glossary/#lazy_evaluation" markdown="1">lazy evaluation</a>
to distinguish it from the more usual <a class="gl-ref" href="../glossary/#eager_evaluation" markdown="1">eager evaluation</a>
that evaluates everything up front.
<code>do_if</code> only evaluates what it absolutely needs to;
most languages do this so that we can safely write things like:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
<p class="continue">If the language always evaluated both branches
then the code shown above would fail whenever <code>x</code> was zero,
even though it&rsquo;s supposed to handle that case.
In this case it might seem obvious what the language should do,
but most languages use lazy evaluation for <code>and</code> and <code>or</code> as well
so that expressions like:</p>
<div class="highlight"><pre><span></span><code><span class="n">reference</span> <span class="ow">and</span> <span class="n">reference</span><span class="o">.</span><span class="n">part</span>
</code></pre></div>
<p class="continue">will produce <code>None</code> if <code>reference</code> is <code>None</code>
and <code>reference.part</code> if it isn&rsquo;t.</p>
<h2 id="interpreter-functions">Section 3.5: Functions</h2>
<p>One way to evaluate the design of a piece of software is
to ask how <a class="gl-ref" href="../glossary/#extensibility" markdown="1">extensible</a> it is,
i.e.,
how easily we can add or change things <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Wilson2022">Wilson2022</a>]</span>.
The answer for our interpreter is now, &ldquo;Pretty easily,&rdquo;
but for our little language is, &ldquo;Not at all,&rdquo;
because there&rsquo;s no way for users to create new operations of their own.
We need to give users a way to define and call functions.</p>
<p>Doing this takes less than 60 lines:</p>
<ol>
<li>
<p>A function definition looks like:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot;def&quot;</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;get&quot;</span><span class="p">,</span> <span class="s2">&quot;num&quot;</span><span class="p">]]</span>
</code></pre></div>
<p>It has a name, a (possibly empty) list of parameter names,
and a single instruction as a body
(which will usually be a <code>"seq"</code> instruction).</p>
</li>
<li>
<p>Functions are stored in the environment like any other value.
    The value stored for the function defined above would be:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;get&quot;</span><span class="p">,</span> <span class="s2">&quot;num&quot;</span><span class="p">]]</span>
</code></pre></div>
<p>We don&rsquo;t need to store the name: that&rsquo;s recorded by the environment,
just like it is for any other variable.</p>
</li>
<li>
<p>A function call looks like:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>
<p>The values passed to the functions are normally expressions rather than constants,
and are <em>not</em> put in a sub-list.
The implementation:
1.  Evaluates all of these expressions.
2.  Looks up the function.
3.  Creates a new environment whose keys are the parameters&rsquo; names
    and whose values are the expressions&rsquo; values.
4.  Calls <code>do</code> to run the function&rsquo;s action and captures the result.
5.  Discards environment created two steps previously.
6.  Returns the function&rsquo;s result.</p>
</li>
<li>
<p>Instead of using a single dictionary to store an environment
    we use a list of dictionaries.
    The first dictionary is the global environment;
    the others store the variables belonging to active function calls.</p>
</li>
<li>
<p>When we get or set a variable,
    we check the most recent environment first
    (i.e., the one that&rsquo;s last in the list);
    if the variable isn&rsquo;t there we look in the global environment.
    We don&rsquo;t look at the environments in between;
    the exercises explore why not.</p>
</li>
</ol>
<div class="callout">
<h3>Scoping rules</h3>
<p>The set of active environments makes up the program&rsquo;s
<span class="ix-entry" ix-key="call stack" markdown="1"><a class="gl-ref" href="../glossary/#call_stack" markdown="1">call stack</a></span>.
For historical reasons,
each environment is sometimes called a <span class="ix-entry" ix-key="call stack!stack frame;stack frame" markdown="1"><a class="gl-ref" href="../glossary/#stack_frame" markdown="1">stack frame</a></span>.
Searching through all active stack frames for a variable
is called is <span class="ix-entry" ix-key="dynamic scoping;scoping!dynamic" markdown="1"><a class="gl-ref" href="../glossary/#dynamic_scoping" markdown="1">dynamic scoping</a></span>.
In contrast,
most programming languages used <span class="ix-entry" ix-key="lexical scoping;scoping!lexical" markdown="1"><a class="gl-ref" href="../glossary/#lexical_scoping" markdown="1">lexical scoping</a></span>,
which figures out what a variable name refers to based on the structure of the program text.</p>
</div>
<p>Here&rsquo;s the implementation of <code>do_def</code>:</p>
<div class="code-sample lang-py" title="func.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_def</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a new function.</span>
<span class="sd">    [&quot;def&quot; name [...params...] body] =&gt; None # and define function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">env_set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">])</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p class="continue">And here&rsquo;s the implementation of <code>do_call</code>:</p>
<div class="code-sample lang-py" title="func.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">do_def</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a new function.</span>
<span class="sd">    [&quot;def&quot; name [...params...] body] =&gt; None # and define function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">env_set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">])</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p class="continue">Our test program and its output are:</p>
<div class="code-sample lang-tll" title="func.tll">
<div class="highlight"><pre><span></span><code>[
    &quot;seq&quot;,
    [
        &quot;def&quot;,
        &quot;double&quot;,
        [&quot;num&quot;],
        [&quot;add&quot;, [&quot;get&quot;, &quot;num&quot;], [&quot;get&quot;, &quot;num&quot;]]
    ],
    [&quot;set&quot;, &quot;a&quot;, 1],
    [
        &quot;repeat&quot;,
        4,
        [
            &quot;seq&quot;,
            [&quot;set&quot;, &quot;a&quot;, [&quot;call&quot;, &quot;double&quot;, [&quot;get&quot;, &quot;a&quot;]]],
            [&quot;print&quot;, [&quot;get&quot;, &quot;a&quot;]]
        ]
    ]
]
</code></pre></div>
</div>
<div class="code-sample lang-out" title="func.out">
<div class="highlight"><pre><span></span><code>2
4
8
16
=&gt; None
</code></pre></div>
</div>
<p>Once again,
Python and other languages work exactly as shown here.
The interpreter
(or the CPU, if we&rsquo;re running code compiled to machine instructions)
reads an instruction,
figures out what operation it corresponds to,
and executes that operation.</p>
<h2 id="interpreter-summary">Section 3.6: Summary</h2>
<figure id="interpreter-concept-map">
  <img src="./interpreter_concept_map.svg" alt="Concept map of interpreter"/>
  <figcaption markdown="1">Figure 3.2: Interpreter concept map.</figcaption>
</figure>

<h2 id="interpreter-exercises">Section 3.7: Exercises</h2>
<h3 class="exercise">Arrays</h3>
<p>Implement fixed-size one-dimensional arrays:
<code>["array", "new", 10]</code> creates an array of 10 elements,
while other instructions get and set particular array elements by index.</p>
<h3 class="exercise">While loops</h3>
<ol>
<li>
<p>Add a <code>while</code> loop using a Python <code>while</code> loop.</p>
</li>
<li>
<p>Add a <code>while</code> loop using recursion.</p>
</li>
</ol>
<h3 class="exercise">Loop counters</h3>
<p>The <code>"repeat"</code> instruction runs some other instruction(s) several times,
but there is no way to access the loop counter inside those instructions.
Modify <code>"repeat"</code> so that programs can do this.
(Hint: allow people to create a new variable to hold the loop counter&rsquo;s current value.)</p>
<h3 class="exercise">Chained maps</h3>
<p>Look at the documentation for the <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap"><code>ChainMap</code></a> class
and modify the interpreter to use that to manage environments.</p>
<h3 class="exercise">Better error handling</h3>
<p>Several of the instruction functions started with <code>assert</code> statements,
which means that users get a stack trace of TLL itself
when there&rsquo;s a bug in their program.</p>
<ol>
<li>
<p>Define a new exception class called <code>TLLException</code>.</p>
</li>
<li>
<p>Write a utility function called <code>check</code>
    that raises a <code>TLLException</code> with a useful error message
    when there&rsquo;s a problem.</p>
</li>
<li>
<p>Add a <code>catch</code> statement to handle these errors.</p>
</li>
</ol>
<h3 class="exercise">Tracing</h3>
<p>Add a <code>--trace</code> command-line flag to the interpreter.
When enabled, it makes TLL print a messages showing each function call and its result.</p>
<h3 class="exercise">Early return</h3>
<p>Add a <code>"return"</code> instruction to TLL that ends a function call immediately
and returns a single value.</p>
<h3 class="exercise">Variable argument lists</h3>
<p>Add variable-length parameter lists to functions.</p>
<h3 class="exercise">Scoping</h3>
<ol>
<li>
<p>Our interpreter looks for variables in
    the current function call&rsquo;s environment
    and in the global environment,
    but not in the environments in between.
    Why not?
    How could looking in those intermediate environments
    make programs harder to debug?</p>
</li>
<li>
<p>The interpreter allows users to define functions inside functions.
    What variables can the inner function access when you do this?
    What variables <em>should</em> it be able to access?
    What would you have to do to enable this?</p>
</li>
</ol>
          
        </main>
      </div>
    </div>
  </body>
</html>
