<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design in Python: Parsing Text</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design in Python</a>
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../tester/">
      A Testing Framework
    </a>
  </li>
  
  <li>
    <a href="../interpreter/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../backup/">
      Versioned File Backups
    </a>
  </li>
  
  <li>
    <a href="../builder/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../templating/">
      A Static Site Generator
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../server/">
      A Web Server
    </a>
  </li>
  
  <li>
    <a href="../matching/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parser/">
      <strong>Parsing Text</strong>
    </a>
  </li>
  
  <li class="todo">
    <a href="../dataframe/">
      A Dataframe
    </a>
  </li>
  
  <li class="todo">
    <a href="../pipeline/">
      A Pipeline Runner
    </a>
  </li>
  
  <li class="todo">
    <a href="../cache/">
      A File Cache
    </a>
  </li>
  
  <li class="todo">
    <a href="../database/">
      A Database
    </a>
  </li>
  
  <li class="todo">
    <a href="../persistence/">
      Object Persistence
    </a>
  </li>
  
  <li class="todo">
    <a href="../binary/">
      Binary Storage
    </a>
  </li>
  
  <li class="todo">
    <a href="../packman/">
      A Package Manager
    </a>
  </li>
  
  <li class="todo">
    <a href="../linter/">
      A Style Checker
    </a>
  </li>
  
  <li class="todo">
    <a href="../codegen/">
      A Code Generator
    </a>
  </li>
  
  <li class="todo">
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li class="todo">
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 10: Parsing Text</h1>


          
            
  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Use existing file formats rather than creating new ones.</li>
  
  <li markdown="1">Parsing in two or more passes is often simpler than parsing in a single pass.</li>
  
  <li markdown="1">Tokenize input text and then analyze the tokens.</li>
  
  <li markdown="1">Every formal language corresponds to an abstract machine and vice versa.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  


            
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#fsm" markdown="1">finite state machine</a>, <a class="gl-ref" href="../glossary/#greedy_algorithm" markdown="1">greedy algorithm</a>, <a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy matching</a>, <a class="gl-ref" href="../glossary/#literal" markdown="1">literal</a>, <a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a>, <a class="gl-ref" href="../glossary/#precedence" markdown="1">precedence</a>, <a class="gl-ref" href="../glossary/#token" markdown="1">token</a>, <a class="gl-ref" href="../glossary/#turing_machine" markdown="1">Turing Machine</a>, <a class="gl-ref" href="../glossary/#well_formed" markdown="1">well-formed</a>, <a class="gl-ref" href="../glossary/#yaml" markdown="1">Yet Another Markup Language</a>
</p>


            <div class="page-toc"></div>
            <p>We constructed objects to create regular expressions in <a class="x-ref" href="../matching/">Chapter 9</a>.
It takes a lot less typing to write them as strings,
but if we do that we need to a <span class="ix-entry" ix-key="parser" markdown="1"><a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a></span>
to convert those strings to objects.</p>
<div class="table"><table id="parser-grammar"><caption>Table 10.1: Regular expression grammar.</caption>
<thead>
<tr>
<th>Meaning</th>
<th>Character</th>
</tr>
</thead>
<tbody>
<tr>
<td>Any literal character <em>c</em></td>
<td><em>c</em></td>
</tr>
<tr>
<td>Beginning of input</td>
<td>^</td>
</tr>
<tr>
<td>End of input</td>
<td>$</td>
</tr>
<tr>
<td>Zero or more of something</td>
<td>*</td>
</tr>
<tr>
<td>Either/or</td>
<td>|</td>
</tr>
<tr>
<td>Grouping</td>
<td>(â€¦)</td>
</tr>
</tbody>
</table>
</div>
<p><a class="tbl-ref" href="../parser/#parser-grammar">Table 10.1</a> shows the grammar our parser will handle.
When our parser is done
it should be able to parse <code>^(a|b|$)*z$</code> as
&ldquo;start of text&rdquo;,
&ldquo;any number of &lsquo;a&rsquo;, &lsquo;b&rsquo;, or &lsquo;$&rsquo;&ldquo;,
&ldquo;a single &lsquo;z&rsquo;,
and &ldquo;end of text&rdquo;.
To keep our discussion focused on parsing
we will create a tree of objects (<a class="fig-ref" href="../parser/#parser-expression-tree">Figure 10.1</a>)
rather than instances of the regular expression classes from <a class="x-ref" href="../matching/">Chapter 9</a>;
the exercises will tackle the problem of converting the former to the latter.</p>
<figure id="parser-expression-tree">
  <img src="./parser_expression_tree.svg" alt="Expression tree for regular expression"/>
  <figcaption markdown="1">Figure 10.1: Representing the result of parsing a regular expression as an tree.</figcaption>
</figure>

<div class="callout">
<h3>Please don&rsquo;t write parsers</h3>
<p>Languages that are comfortable for people to read and write
are usually difficult for computers to understand
and vice versa,
so we need parsers to translate the former into the latter.
However,
the world doesn&rsquo;t need more file formats:
if you need a configuration file or lookup table,
please use CSV, JSON, <a class="gl-ref" href="../glossary/#yaml" markdown="1">YAML</a>,
or something else that already has an acronym
rather than inventing something of your own.</p>
</div>
<h2 id="parser-tokenize">Section 10.2: Tokenization</h2>
<p>A <span class="ix-entry" ix-key="token (in parsing)" markdown="1"><a class="gl-ref" href="../glossary/#token" markdown="1">token</a></span> is an atom of text,
such as the digits making up a number or the letters making up a variable name.
Our grammar&rsquo;s tokens are the special characters <code>*</code>, <code>|</code>, <code>(</code>, <code>)</code>, <code>^</code>, and <code>$</code>;
any sequence of one or more other characters is a single multi-letter token.
This classification guides the design of our parser:</p>
<ol>
<li>
<p>If a character is special, create a token for it.</p>
</li>
<li>
<p>If it is a <span class="ix-entry" ix-key="literal (in parsing)" markdown="1"><a class="gl-ref" href="../glossary/#literal" markdown="1">literal</a></span> then
    combine it with the current literal if there is one
    or start a new literal.</p>
</li>
<li>
<p>Since <code>^</code> and <code>$</code> are either special or regular depending on position,
    we must treat them as separate tokens or as part of a literal
    based on where they appear.</p>
</li>
</ol>
<p>We can translate these rules almost directly into code
to create a list of dictionaries whose keys are <code>"kind"</code> and <code>"loc"</code> (short for location),
with the extra key <code>"value"</code> for literal values:</p>
<div class="code-sample lang-py" title="tokenizer_collapse.py">
<div class="highlight"><pre><span></span><code><span class="n">SIMPLE</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;*&quot;</span><span class="p">:</span> <span class="s2">&quot;Any&quot;</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">:</span> <span class="s2">&quot;Alt&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span> <span class="s2">&quot;GroupStart&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span> <span class="s2">&quot;GroupEnd&quot;</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">SIMPLE</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="n">SIMPLE</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Start&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;End&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combine_or_push</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p>The helper function <code>combine_or_push</code> does exactly what its name says.
If the thing most recently added to the list of tokens isn&rsquo;t a literal,
the new character becomes a new token;
otherwise,
it appends the new character to the literal:</p>
<div class="code-sample lang-py" title="tokenizer_collapse.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">combine_or_push</span><span class="p">(</span><span class="n">so_far</span><span class="p">,</span> <span class="n">character</span><span class="p">,</span> <span class="n">location</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">so_far</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">so_far</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;Lit&quot;</span><span class="p">):</span>
        <span class="n">so_far</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">character</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">location</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">so_far</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">character</span>
</code></pre></div>
</div>
<p>We can try this out with a three-line test program:</p>
<div class="code-sample lang-py" title="tokenizer_collapse_example.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">json</span>

<span class="kn">from</span> <span class="nn">tokenizer_collapse</span> <span class="kn">import</span> <span class="n">tokenize</span>

<span class="n">test</span> <span class="o">=</span> <span class="s2">&quot;^a^b*&quot;</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="tokenizer_collapse_example.out">
<div class="highlight"><pre><span></span><code>^a^b* =&gt; [
  {
    &quot;kind&quot;: &quot;Start&quot;,
    &quot;loc&quot;: 0
  },
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;a^b&quot;,
    &quot;loc&quot;: 1
  },
  {
    &quot;kind&quot;: &quot;Any&quot;,
    &quot;loc&quot;: 4
  }
]
</code></pre></div>
</div>
<p>This simple tokenizer is readable, efficient, and wrong.
The problem is that the expression <code>ab*</code> is supposed to mean
&ldquo;a single <code>a</code> followed by zero or more <code>b</code>&rdquo;.
If we combine the letters <code>a</code> and <code>b</code> as we read them,
though,
we wind up with &ldquo;zero or more repetitions of <code>ab</code>&rdquo;.
In jargon terms,
our parser is <span class="ix-entry" ix-key="greedy algorithm;algorithm!greedy" markdown="1"><a class="gl-ref" href="../glossary/#greedy_algorithm" markdown="1">greedy</a></span>,
but we need it to be <span class="ix-entry" ix-key="lazy algorithm;algorithm!lazy" markdown="1"><a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy</a></span>:</p>
<div class="code-sample lang-py" title="tokenizer_collapse_error.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">json</span>

<span class="kn">from</span> <span class="nn">tokenizer_collapse</span> <span class="kn">import</span> <span class="n">tokenize</span>

<span class="n">test</span> <span class="o">=</span> <span class="s2">&quot;ab*&quot;</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="tokenizer_collapse_error.out">
<div class="highlight"><pre><span></span><code>ab* =&gt; [
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;ab&quot;,
    &quot;loc&quot;: 0
  },
  {
    &quot;kind&quot;: &quot;Any&quot;,
    &quot;loc&quot;: 2
  }
]
</code></pre></div>
</div>
<p>The solution is to treat each regular character as its own literal in this stage
and combine them later.
Doing this lets us get rid of the nested <code>if</code> for handling <code>^</code> and <code>$</code> as well:</p>
<div class="code-sample lang-py" title="tokenizer.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">SIMPLE</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="n">SIMPLE</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Start&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;End&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">c</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p>Software isn&rsquo;t done until it&rsquo;s tested,
so let&rsquo;s build some tests.
The listing below shows a few of these
along with the output for the full set:</p>
<div class="code-sample lang-py" title="test_tokenizer.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">tokenizer</span> <span class="kn">import</span> <span class="n">tokenize</span>

<span class="k">def</span> <span class="nf">test_tokenize_single_character</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}]</span>

<span class="k">def</span> <span class="nf">test_tokenize_char_sequence</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">test_tokenize_start_anchor_alone</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Start&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}]</span>

<span class="k">def</span> <span class="nf">test_tokenize_start_anchor_followed_by_characters</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Start&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">test_tokenize_complex_expression</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;^a*(bcd|e^)*f$gh$&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Start&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Any&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;GroupStart&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;d&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Alt&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;e&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;^&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;GroupEnd&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Any&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">11</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;f&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;$&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;g&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;h&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;End&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">16</span><span class="p">},</span>
    <span class="p">]</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="test_tokenizer.out">
<div class="highlight"><pre><span></span><code>========================= test session starts ==========================
platform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0
rootdir: /u/sdxpy/parser
plugins: pyfakefs-4.6.3
collected 18 items

test_tokenizer.py ..................                             [100%]

========================== 18 passed in 0.02s ==========================
</code></pre></div>
</div>
<h2 id="parser-tree">Section 10.3: Assembling the Tree</h2>
<p>We now have a list of tokens,
but we need a tree that represents the nesting introduced by parentheses
and the way that <code>*</code> applies to whatever comes before it.
Let&rsquo;s trace a few cases:</p>
<ol>
<li>
<p>If the regular expression is <code>a</code>,
    we create a <code>Lit</code> token for the letter <code>"a"</code>.</p>
</li>
<li>
<p>If the regular expression is <code>a*</code>,
    we create a <code>Lit</code> token for the <code>"a"</code> and append it to the output list.
    When we see the <code>*</code>,
    we take that <code>Lit</code> token off the tail of the output list
    and replace it with an <code>Any</code> token that has the <code>Lit</code> token as its child.</p>
</li>
<li>
<p>What about the regular expression <code>(ab)</code>?
    We don&rsquo;t know how long the group is going to be when we see the opening <code>(</code>,
    so we add the parenthesis to the output as a marker.
    We then add the <code>Lit</code> tokens for the <code>"a"</code> and <code>"b"</code> until we see the <code>)</code>,
    at which point we pull tokens off the end of the output list
    until we get back to the <code>(</code> marker.
    When we find it,
    we put everything we have temporarily collected into a <code>Group</code> token and append it to the output list.
    This algorithm automatically handles patterns like <code>(a*)</code> and <code>(a(b*)c)</code>.</p>
</li>
<li>
<p>What about <code>a|b</code>?
    We append a <code>Lit</code> token for <code>"a"</code>, get the <code>|</code> andâ€”we&rsquo;re stuck,
    because we don&rsquo;t yet have the next token we need to finish building the <code>Alt</code>.</p>
</li>
</ol>
<p>One way to solve this problem is to check to see if the thing on the top of the stack is combinable
each time we append a new token.
However,
that still doesn&rsquo;t handle <code>a|b*</code> properly:
the pattern is supposed to mean &ldquo;one <code>"a"</code> or any number of <code>"b"</code>&rdquo;,
but the check-and-combine strategy will turn it into the equivalent of <code>(a|b)*</code>.</p>
<p>A better solution is to leave some partially-completed tokens in the output
and compress them later (<a class="fig-ref" href="../parser/#parser-mechanics">Figure 10.2</a>).
If our input is <code>a|b</code> we can:</p>
<ol>
<li>
<p>Append a <code>Lit</code> token for <code>"a"</code>.</p>
</li>
<li>
<p>When we see <code>|</code>,
    make that <code>Lit</code> token the left child of the <code>Alt</code>
    and append that to the output without filling in the right child.</p>
</li>
<li>
<p>Append the <code>Lit</code> token for <code>"b"</code>.</p>
</li>
<li>
<p>After all tokens have been handled,
    look for partially-completed <code>Alt</code> tokens and make whatever comes after them their right child.</p>
</li>
</ol>
<p class="continue">Again, this automatically handles patterns like <code>(ab)|c*|(de)</code>.</p>
<figure id="parser-mechanics">
  <img src="./parser_mechanics.svg" alt="Mechanics of combining tokens"/>
  <figcaption markdown="1">Figure 10.2: Mechanics of combining tokens while parsing regular expressions.</figcaption>
</figure>

<p>Let&rsquo;s turn this idea into code.
The main structure of our parser is:</p>
<div class="code-sample lang-py" title="parser.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">tokenizer</span> <span class="kn">import</span> <span class="n">tokenize</span>

<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_tokens</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_tokens</span><span class="p">):</span>
        <span class="n">is_last</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_tokens</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">handle</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">is_last</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
</div>
<p>We handle tokens case by case
(with a few assertions to check that patterns are <a class="gl-ref" href="../glossary/#well_formed" markdown="1">well formed</a>):</p>
<div class="code-sample lang-py" title="parser.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">is_last</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Lit&quot;</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Start&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Should not have start token after other tokens&quot;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;End&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">is_last</span><span class="p">,</span> <span class="s2">&quot;Should not have end token before other tokens&quot;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;GroupStart&quot;</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;GroupEnd&quot;</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_end</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">token</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;No operand for &quot;*&quot; (</span><span class="si">{</span><span class="n">token</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="n">token</span><span class="p">[</span><span class="s2">&quot;child&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alt&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;No operand for &quot;*&quot; (</span><span class="si">{</span><span class="n">token</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="n">token</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">token</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;UNIMPLEMENTED </span><span class="si">{</span><span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
</code></pre></div>
</div>
<p>When we find the <code>)</code> that marks the end of a group,
we take items from the end of the output list
until we find the matching start
and use them to create a group:</p>
<div class="code-sample lang-py" title="parser.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">group_end</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="n">group</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Group&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">],</span> <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[]}</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Unmatched end parenthesis (</span><span class="si">{</span><span class="n">token</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;GroupStart&quot;</span><span class="p">:</span>
            <span class="n">group</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="n">group</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">group</span>
</code></pre></div>
</div>
<p>Finally,
when we have finished with the input,
we go through the output list one last time to fill in the right side of <code>Alt</code>s:</p>
<div class="code-sample lang-py" title="parser.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="n">cooked</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alt&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cooked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;No right operand for alt (</span><span class="si">{</span><span class="n">token</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="n">token</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cooked</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cooked</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cooked</span>
</code></pre></div>
</div>
<p>Once again,
it&rsquo;s not done until we&rsquo;ve tested it:</p>
<div class="code-sample lang-py" title="test_parser.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">parser</span> <span class="kn">import</span> <span class="n">parse</span>

<span class="k">def</span> <span class="nf">test_parse_empty_string</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">test_parse_single_literal</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">parse</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">}]</span>

<span class="k">def</span> <span class="nf">test_parse_multiple_literals</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">},</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">test_parse_alt_of_groups</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">parse</span><span class="p">(</span><span class="s2">&quot;a|(bc)&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Alt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">},</span>
            <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Group&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">},</span>
                    <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;Lit&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">},</span>
                <span class="p">],</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">]</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="test_parser.out">
<div class="highlight"><pre><span></span><code>========================= test session starts ==========================
platform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0
rootdir: /u/sdxpy/parser
plugins: pyfakefs-4.6.3
collected 15 items

test_parser.py ...............                                   [100%]

========================== 15 passed in 0.01s ==========================
</code></pre></div>
</div>
<p>Our tokenizer and parser are doing some complex things,
but are still less than 100 lines of code.
Compared to parsers for formats like JSON and YAML,
though,
they are still quite simple.
If we have more operators with different
<span class="ix-entry" ix-key="operator precedence!implementing" markdown="1"><a class="gl-ref" href="../glossary/#precedence" markdown="1">precedences</a></span>
we should switch to the
<span class="ix-entry" ix-key="shunting-yard algorithm;parser!shunting-yard algorithm" markdown="1"><a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a></span>,
and if we need to parse something as complex as Python
we should explore tools like <span class="ix-entry" ix-key="ANTLR" markdown="1"><a href="https://www.antlr.org/">ANTLR</a></span>
that can generate a parser automatically from a description of the language to be parsed.
As we said at the start,
though,
if our design requires us to write a parser we should come up with a better design.</p>
<div class="callout">
<h3>The limits of computing</h3>
<p>One of the most important theoretical results in computer science is that
every formal language corresponds to a type of abstract machine and vice versa,
and that some languages (or machines) are more or less powerful than others.
For example,
every regular expression corresponds to
a <span class="ix-entry" ix-key="finite state machine!correspondence with regular expressions" markdown="1"><a class="gl-ref" href="../glossary/#fsm" markdown="1">finite state machine</a></span> (FSM)
like the one in <a class="fig-ref" href="../parser/#parser-fsm">Figure 10.3</a>.
As powerful as FSMs are,
they cannot match things like nested parentheses or HTML tags;
<span class="ix-entry" ix-key="sin!using regular expressions to parse HTML" markdown="1"><a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">attempting to do so is a sin</a></span>.
If you add a stack to the system you can process a much richer set of languages,
and if you add two stacks you have something equivalent to a <span class="ix-entry" ix-key="Turing Machine" markdown="1"><a class="gl-ref" href="../glossary/#turing_machine" markdown="1">Turing Machine</a></span>
that can do any conceivable computation.
<span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Conery2021">Conery2021</a>]</span> is a good introduction to this idea
(and others)
for self-taught developers.</p>
</div>
<figure id="parser-fsm">
  <img src="./parser_fsm.svg" alt="Finite state machine"/>
  <figcaption markdown="1">Figure 10.3: A finite state machine equivalent to a regular expression.</figcaption>
</figure>

<h2 id="templating-summary">Section 10.4: Summary</h2>
<figure id="parser-concept-map">
  <img src="./parser_concept_map.svg" alt="Concept map for parser"/>
  <figcaption markdown="1">Figure 10.4: Parser concept map.</figcaption>
</figure>

<h2 id="parser-exercises">Section 10.5: Exercises</h2>
<h3 class="exercise">Create objects</h3>
<p>Modify the parser to return instances of classes derived from
the <code>RegexBase</code> class of <a class="x-ref" href="../matching/">Chapter 9</a>.</p>
<h3 class="exercise">Escape characters</h3>
<p>Modify the parser to handle escape characters,
so that (for example) <code>\*</code> is interpreted as a literal &lsquo;*&rsquo; character
and <code>\\</code> is interpreted as a literal backslash.</p>
<h3 class="exercise">Lazy matching</h3>
<p>Modify the parser so that <code>*?</code> is interpreted as a single token
meaning &ldquo;lazy match zero or more&rdquo;.</p>
<h3 class="exercise">Character sets</h3>
<p>Modify the parser so that expressions like <code>[xyz]</code> are interpreted to mean
&ldquo;match any one of the characters &lsquo;x&rsquo;, &lsquo;y&rsquo;, or &lsquo;z&rsquo;&ldquo;.</p>
<h3 class="exercise">Back reference</h3>
<p>Modify the tokenizer so that it recognizes <code>\1</code>, <code>\2</code>, and so on to mean &ldquo;back reference&rdquo;.
The number may contain any number of digits.</p>
<h3 class="exercise">Tokenize HTML</h3>
<ol>
<li>
<p>Write a tokenizer for a subset of HTML that consists of:</p>
<ul>
<li>Opening tags without attributes, such as <code>&lt;div&gt;</code> and <code>&lt;p&gt;</code></li>
<li>Closing tags, such as <code>&lt;/p&gt;</code> and <code>&lt;/div&gt;</code></li>
<li>Plain text between tags that does <em>not</em> contain &lsquo;&lt;&rsquo; or &lsquo;&gt;&rsquo; characters</li>
</ul>
</li>
<li>
<p>Modify the tokenizer to handle <code>key="value"</code> attributes in opening tags.</p>
</li>
<li>
<p>Write tests for your tokenizer.</p>
</li>
</ol>
<p>You may use Python&rsquo;s own <a href="https://docs.python.org/3/library/re.html">re</a> module for tokenization.</p>
<h3 class="exercise">Efficiency</h3>
<p>The parser developed in this chapter creates and discards a lot of objects.
How can you make it more efficient?</p>
<h3 class="exercise">Nested lists</h3>
<p>Write a function that accepts a string representing nested lists containing numbers
and returns the actual list.
For example, the input <code>[1, [2, [3, 4], 5]]</code>
should produce the corresponding Python list.</p>
<h3 class="exercise">The Shunting Yard Algorithm</h3>
<ol>
<li>
<p>Use the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a>
    to implement a tokenizer for a simple subset of arithmetic that includes:</p>
<ul>
<li>single-letter variable names</li>
<li>single-digit numbers</li>
<li>the <code>+</code>, <code>*</code>, and <code>^</code> operators, where <code>+</code> has the lowest precedence and <code>^</code> has the highest</li>
</ul>
</li>
<li>
<p>Write tests for your tokenizer.</p>
</li>
</ol>
<h3 class="exercise">Using the right tools</h3>
<ol>
<li>
<p>Rewrite the regular expression parser from this chapter
    using the <a href="https://pyparsing-docs.readthedocs.io/">pyparsing</a> module.</p>
</li>
<li>
<p>Did learning this module take more or less time
    than solving the problem without it?
    How many times would you have to use the module to amortize its learning overhead?</p>
</li>
</ol>
          
        </main>
      </div>
    </div>
  </body>
</html>
