<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <title>Software Design in Python: A Testing Framework</title>
</head>

  <body>
    <div class="row">
      <div class="column">
        <p>
  <img src="../logo.svg" alt="site logo" style="width: 10%" />
  <a href="../">Software Design in Python</a>
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../tester/">
      <strong>A Testing Framework</strong>
    </a>
  </li>
  
  <li class="todo">
    <a href="../backup/">
      Versioned File Backups
    </a>
  </li>
  
  <li class="todo">
    <a href="../interpreter/">
      An Interpreter
    </a>
  </li>
  
  <li class="todo">
    <a href="../dataframe/">
      A Dataframe
    </a>
  </li>
  
  <li class="todo">
    <a href="../pipeline/">
      A Pipeline Runner
    </a>
  </li>
  
  <li class="todo">
    <a href="../builder/">
      A Build Manager
    </a>
  </li>
  
  <li class="todo">
    <a href="../matching/">
      Matching Regular Expressions
    </a>
  </li>
  
  <li class="todo">
    <a href="../parser/">
      Parsing Regular Expressions
    </a>
  </li>
  
  <li class="todo">
    <a href="../server/">
      A Web Server
    </a>
  </li>
  
  <li class="todo">
    <a href="../cache/">
      A File Cache
    </a>
  </li>
  
  <li class="todo">
    <a href="../database/">
      A Database
    </a>
  </li>
  
  <li class="todo">
    <a href="../persistence/">
      Object Persistence
    </a>
  </li>
  
  <li class="todo">
    <a href="../binary/">
      Binary Storage
    </a>
  </li>
  
  <li class="todo">
    <a href="../templating/">
      HTML Templating
    </a>
  </li>
  
  <li class="todo">
    <a href="../packman/">
      A Package Manager
    </a>
  </li>
  
  <li class="todo">
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li class="todo">
    <a href="../linter/">
      A Style Checker
    </a>
  </li>
  
  <li class="todo">
    <a href="../codegen/">
      A Code Generator
    </a>
  </li>
  
  <li class="todo">
    <a href="../vm/">
      A Virtual Machine and Assembler
    </a>
  </li>
  
  <li class="todo">
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

      </div>
      <div id="printable" class="column bordered">
        <main>
	  
  <h1>Chapter 2: A Testing Framework</h1>


	  
          
  
  <ul class="syllabus">
  
  <li markdown="1">Functions are objects you can save in data structures or pass to other functions.</li>
  
  <li markdown="1">Python stores local and global variables in dictionary-like structures.</li>
  
  <li markdown="1">A unit test function performs an operation on a fixture and passes, fails, or produces an error.</li>
  
  <li markdown="1">A program can introspect to find functions and other objects at runtime.</li>
  
  <li markdown="1">Temporarily replacing functions with mock objects can simplify testing.</li>
  
  <li markdown="1">Python defines protocols so that users' code can be triggered by keywords in the language.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


	  
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#absolute_error" markdown="1">absolute error</a>, <a class="gl-ref" href="../glossary/#actual_result" markdown="1">actual result (of test)</a>, <a class="gl-ref" href="../glossary/#alias" markdown="1">alias</a>, <a class="gl-ref" href="../glossary/#assertion" markdown="1">assertion</a>, <a class="gl-ref" href="../glossary/#context_manager" markdown="1">context manager</a>, <a class="gl-ref" href="../glossary/#defensive_programming" markdown="1">defensive programming</a>, <a class="gl-ref" href="../glossary/#docstring" markdown="1">docstring</a>, <a class="gl-ref" href="../glossary/#error_test" markdown="1">error (result of test)</a>, <a class="gl-ref" href="../glossary/#expected_result" markdown="1">expected result (of test)</a>, <a class="gl-ref" href="../glossary/#fail_test" markdown="1">failure (result of test)</a>, <a class="gl-ref" href="../glossary/#fixture" markdown="1">fixture</a>, <a class="gl-ref" href="../glossary/#introspection" markdown="1">introspection</a>, <a class="gl-ref" href="../glossary/#mock_object" markdown="1">mock object</a>, <a class="gl-ref" href="../glossary/#pass_test" markdown="1">pass (result of test)</a>, <a class="gl-ref" href="../glossary/#relative_error" markdown="1">relative error</a>, <a class="gl-ref" href="../glossary/#throw_exception" markdown="1">throw exception</a>, <a class="gl-ref" href="../glossary/#unit_test" markdown="1">unit test</a>
</p>


          <p>We&rsquo;re going to write a lot of programs in this book,
which means we&rsquo;re going to write a lot of <a class="gl-ref" href="../glossary/#unit_test" markdown="1">unit tests</a>.
A tool to manage these should find and run tests automatically
so that we don&rsquo;t overlook them when we&rsquo;re tired,
distracted,
or up against a deadline.</p>
<p>Our design was inspired by <a href="https://docs.pytest.org/">pytest</a>,
which in turn was inspired by earlier tools <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Meszaros2007">Meszaros2007</a>]</span>.
It introduces the single most important idea in this book:</p>
<div class="center">
<p><em>A program is just another kind of data.</em></p>
</div>
<h2 id="tester-funcobj">Section 2.1: Storing and Running Tests</h2>
<p>The first thing we need to understand is that a function is an object.
While a string&rsquo;s bytes represent characters
and an image&rsquo;s bytes represent pixels,
a function&rsquo;s bytes represent instructions.
The code:</p>
<div class="code-sample lang-py" title="func_obj.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">tells Python to create an object in memory
that contains the instructions to print a string
and assign that object to the variable <code>example</code>.&rdquo;
We can create an <a class="gl-ref" href="../glossary/#alias" markdown="1">alias</a> for the function
by assigning it to another variable:</p>
<div class="code-sample lang-py" title="func_obj.py">
<div class="highlight"><pre><span></span><code><span class="n">alias</span> <span class="o">=</span> <span class="n">example</span>
<span class="n">alias</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="func_obj.out">
<div class="highlight"><pre><span></span><code>in example
</code></pre></div>
</div>
<p class="continue">or replace the function by assigning a new value
to the original variable:</p>
<div class="code-sample lang-py" title="replacement.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">replacement</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in replacement&quot;</span><span class="p">)</span>

<span class="n">example</span> <span class="o">=</span> <span class="n">replacement</span>
<span class="n">example</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="replacement.out">
<div class="highlight"><pre><span></span><code>in replacement
</code></pre></div>
</div>
<p>We can also store functions in a list just like numbers or strings:</p>
<div class="code-sample lang-py" title="func_list.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">first</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">second</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Second&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">third</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Third&quot;</span><span class="p">)</span>

<span class="n">everything</span> <span class="o">=</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span><span class="p">]</span>
<span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">everything</span><span class="p">:</span>
    <span class="n">func</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="func_list.out">
<div class="highlight"><pre><span></span><code>First
Second
Third
</code></pre></div>
</div>
<p class="continue">When we loop over the list <code>everything</code>,
Python assigns each function to the variable <code>func</code> in turn.
We can then call the function as <code>func()</code>
just as we called <code>example</code> using <code>alias()</code>.</p>
<p>With this in hand,
we can register tests by appending functions to a list:</p>
<div class="code-sample lang-py" title="dry_run.py">
<div class="highlight"><pre><span></span><code><span class="n">HOPE_TESTS</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">hope_that</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">HOPE_TESTS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Each test does something to a <a class="gl-ref" href="../glossary/#fixture" markdown="1">fixture</a>
and uses <a class="gl-ref" href="../glossary/#assertion" markdown="1">assertions</a>
to compare the <a class="gl-ref" href="../glossary/#actual_result" markdown="1">actual result</a>
against the <a class="gl-ref" href="../glossary/#expected_result" markdown="1">expected result</a>:</p>
<div class="code-sample lang-py" title="dry_run.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_sign_negative</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_sign_positive</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_sign_zero</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">test_sign_error</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sgn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="n">hope_that</span><span class="p">(</span><span class="n">test_sign_negative</span><span class="p">)</span>
<span class="n">hope_that</span><span class="p">(</span><span class="n">test_sign_positive</span><span class="p">)</span>
<span class="n">hope_that</span><span class="p">(</span><span class="n">test_sign_zero</span><span class="p">)</span>
<span class="n">hope_that</span><span class="p">(</span><span class="n">test_sign_error</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The outcome of each test is exactly one of:</p>
<ul>
<li>
<p><a class="gl-ref" href="../glossary/#pass_test" markdown="1">Pass</a>:
    the test subject works as expected.</p>
</li>
<li>
<p><a class="gl-ref" href="../glossary/#fail_test" markdown="1">Fail</a>:
    something is wrong with the test subject.</p>
</li>
<li>
<p><a class="gl-ref" href="../glossary/#error_test" markdown="1">Error</a>:
    something is wrong in the test itself,
    which means we don&rsquo;t know whether the test subject is working properly or not.</p>
</li>
</ul>
<p>We need to distinguish failing tests from broken ones
in order to implement this classification scheme.
Our rule is that
if a test <a class="gl-ref" href="../glossary/#throw_exception" markdown="1">throws</a> an <code>AssertionError</code>
then one of our checks is reporting a failure,
while any other kind of exception indicates that the test contains an error.</p>
<p>Putting this all together gives us a function <code>run_tests</code>
that runs all registered tests
and counts how many outcomes of each kind it sees:</p>
<div class="code-sample lang-py" title="dry_run.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">run_tests</span><span class="p">():</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pass&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;fail&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">HOPE_TESTS</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">test</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;pass&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;fail&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pass </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fail </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fail&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">run_tests</span><span class="p">()</span>
</code></pre></div>
</div>
<p class="continue">If a test completes without an exception, it passes.
If any of the assertions inside it raise an <code>AssertionError</code> the test fails,
and if it raises any other exception it&rsquo;s an error.
After all tests are run,
<code>run_tests</code> reports the number of results of each kind:</p>
<div class="code-sample lang-out" title="dry_run.out">
<div class="highlight"><pre><span></span><code>pass 2
fail 1
error 1
</code></pre></div>
</div>
<div class="callout">
<h3>Independence</h3>
<p>We&rsquo;re appending tests to a list,
so they will be run in the order in which they are registered.
We should not rely on that:
every unit test should work independently
so that an error or failure in an early test
doesn&rsquo;t affect other tests&rsquo; behavior.</p>
</div>
<h2 id="tester-reflection">Section 2.2: Finding Functions</h2>
<p>Registering tests by hand is clumsy and error-prone:
sooner or later we&rsquo;ll add a test twice or forget to add it at all.
We would therefore like our tool to find tests for itself.
It can do this by exploiting the fact that
Python stores our variables in a structure similar to a dictionary.</p>
<p>Run the Python interpreter and call the <code>globals</code> function:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; globals()
{
    &#39;__name__&#39;: &#39;__main__&#39;,
    &#39;__doc__&#39;: None,
    &#39;__package__&#39;: None,
    &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;,
    &#39;__spec__&#39;: None,
    &#39;__annotations__&#39;: {},
    &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;
}
</code></pre></div>
<p class="continue">As the output shows,
<code>globals</code> returns a copy of the dictionary that Python uses
to store all the variables at the top (global) level of your program.
Since we just started the interpreter,
we see the variables that Python defines automatically.
(By convention,
Python uses double underscores for names that mean something special to it.)</p>
<p>What happens when we define a variable of our own?</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; my_variable = 123
&gt;&gt;&gt; globals()
{
    &#39;__name__&#39;: &#39;__main__&#39;,
    &#39;__doc__&#39;: None,
    &#39;__package__&#39;: None,
    &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;,
    &#39;__spec__&#39;: None,
    &#39;__annotations__&#39;: {},
    &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;,
    &#39;my_variable&#39;: 123
}
</code></pre></div>
<p class="continue">Sure enough,
<code>my_variable</code> is now in the global dictionary.</p>
<div class="callout">
<h3>Local Variables</h3>
<p>Another function called <code>locals</code> returns
all the variables defined in the current (local) scope:</p>
<div class="code-sample lang-py" title="show_locals.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">show_off</span><span class="p">(</span><span class="n">some_parameter</span><span class="p">):</span>
    <span class="n">some_variable</span> <span class="o">=</span> <span class="n">some_parameter</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;local values&quot;</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span>

<span class="n">show_off</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="show_locals.out">
<div class="highlight"><pre><span></span><code>local values {&#39;some_parameter&#39;: &#39;hello&#39;, &#39;some_variable&#39;: &#39;hellohello&#39;}
</code></pre></div>
</div>
</div>
<p>If a program&rsquo;s variables are stored in a dictionary,
we can iterate over that dictionary&rsquo;s keys
to find all the functions whose names start with <code>test_</code>
and put them in a list:</p>
<div class="code-sample lang-py" title="find_list_test_funcs.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_addition</span><span class="p">():</span>
    <span class="k">assert</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">4</span>

<span class="k">def</span> <span class="nf">test_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">9</span>

<span class="k">def</span> <span class="nf">test_remainder</span><span class="p">():</span>
    <span class="k">assert</span> <span class="mi">15</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1"># this is wrong</span>

<span class="k">def</span> <span class="nf">find_tests</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;all the test functions&quot;</span><span class="p">,</span> <span class="n">find_tests</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="find_list_test_funcs.out">
<div class="highlight"><pre><span></span><code>all the test functions [&lt;function test_addition at 0x10659e160&gt;, \
&lt;function test_multiplication at 0x106769a60&gt;, &lt;function test_remainder \
at 0x106769ee0&gt;]
</code></pre></div>
</div>
<p class="continue">Having a program find things in itself as it&rsquo;s running is called <a class="gl-ref" href="../glossary/#introspection" markdown="1">introspection</a>;
we will use it in several upcoming chapters.
Notice that when we print a function,
Python shows us its name and its address in memory.
We have no use for the address,
but we&rsquo;ll come back to the name shortly.</p>
<p>Combining introspection with the pass-fail-error pattern of the previous section
gives us something that will look up test functions,
run them,
and summarize their results:</p>
<div class="code-sample lang-py" title="find_report_tests.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">run_tests</span><span class="p">():</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s2">&quot;passed&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s2">&quot;failed&quot;</span><span class="p">)</span>

<span class="n">run_tests</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="find_report_tests.out">
<div class="highlight"><pre><span></span><code>test_addition passed
test_multiplication passed
test_remainder failed
</code></pre></div>
</div>
<div class="callout">
<h3>Calling Conventions</h3>
<p>We actually can&rsquo;t call a function we&rsquo;ve found by introspection unless:</p>
<ol>
<li>
<p>we know its <a class="gl-ref" href="../glossary/#function_signature" markdown="1">signature</a>
    (i.e, how many parameters of what type it needs in what order)
    or</p>
</li>
<li>
<p>the function uses <code>*args*</code> or <code>**kwargs</code>
    to capture any number of &ldquo;extra&rdquo; arguments.</p>
</li>
</ol>
<p>To keep things simple,
most testing frameworks require unit test functions to take no parameters
so that they can be called as <code>test()</code>.</p>
</div>
<h2 id="tester-further">Section 2.3: Going Further</h2>
<p>The next step is to get our tool to tell us which tests have passed or failed
and to use test functions&rsquo; docstrings to control which tests are run.
The key to doing both is the fact that functions can have attributes
just like any other object in Python.
The function <code>dir</code> (short for &ldquo;directory&rdquo;) returns a list of those attributes&rsquo; names:</p>
<div class="code-sample lang-py" title="func_dir.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="s2">&quot;Docstring for example.&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in example&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">example</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="func_dir.out">
<div class="highlight"><pre><span></span><code>[&#39;__annotations__&#39;, &#39;__call__&#39;, &#39;__class__&#39;, &#39;__closure__&#39;, &#39;__code__&#39;, \
&#39;__defaults__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, \
&#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__get__&#39;, &#39;__getattribute__&#39;, \
&#39;__globals__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, \
&#39;__kwdefaults__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__name__&#39;, \
&#39;__ne__&#39;, &#39;__new__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, \
&#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;]
</code></pre></div>
</div>
<p>Most programmers never need to use most of these,
but <code>__doc__</code> holds the function&rsquo;s <a class="gl-ref" href="../glossary/#docstring" markdown="1">docstring</a>
and <code>__name__</code> holds its original name:</p>
<div class="code-sample lang-py" title="func_attr.py">
<div class="highlight"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;docstring:&quot;</span><span class="p">,</span> <span class="n">example</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">example</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="func_attr.out">
<div class="highlight"><pre><span></span><code>docstring: Docstring for example.
name: example
</code></pre></div>
</div>
<p>We can print each function&rsquo;s name when reporting problems,
but we can also embed instructions for the test framework in them.
For example,
we could decide that the string <code>"test:skip"</code> means &ldquo;skip this test&rdquo;,
while <code>"test:fail"</code> means &ldquo;we expect this test to fail&rdquo;.
Let&rsquo;s rewrite our tests to show this off:</p>
<div class="code-sample lang-py" title="docstring.py">
<div class="highlight"><pre><span></span><code><span class="n">TEST_FAIL</span> <span class="o">=</span> <span class="s2">&quot;test:fail&quot;</span>
<span class="n">TEST_SKIP</span> <span class="o">=</span> <span class="s2">&quot;test:skip&quot;</span>

<span class="k">def</span> <span class="nf">test_sign_negative</span><span class="p">():</span>
    <span class="s2">&quot;test:skip&quot;</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_sign_positive</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_sign_zero</span><span class="p">():</span>
    <span class="s2">&quot;test:fail&quot;</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">test_sign_error</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Expect an error.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">sgn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p class="continue">and then modify <code>run_tests</code> to look for these strings and act accordingly:</p>
<div class="code-sample lang-py" title="docstring.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">run_tests</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
    <span class="n">prefixed_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">prefixed_names</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">TEST_SKIP</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skip: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pass: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">TEST_FAIL</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pass (expected failure): </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fail: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;/</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error: </span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">doc</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The output is now:</p>
<div class="code-sample lang-out" title="docstring.out">
<div class="highlight"><pre><span></span><code>skip: test_sign_negative
error: test_sign_positive argument of type &#39;NoneType&#39; is not iterable
pass (expected failure): test_sign_zero
error: test_sign_error/Expect an error. name &#39;sgn&#39; is not defined
</code></pre></div>
</div>
<h2>Mock Objects</h2>
<p>We can do more than look up functions:
we can change them to make testing easier.
For example,
if our test relies on the time of day,
we can temporarily replace the real <code>time.time</code> function
with one that returns a specific value.
Similarly,
if a test needs data from a database,
we can temporarily replace the function that gets the data
with one that returns a small, constant dataset
that has exactly the properties our test wants.</p>
<p>Temporary replacements like this are called <a class="gl-ref" href="../glossary/#mock_object" markdown="1">mock objects</a>
because they mimic the essential behavior of the real objects in the program.
We usually use objects even if the thing we&rsquo;re replacing is a function;
we can do this because Python lets us create objects that can be called just like functions
by defining a <code>__call__</code> method:</p>
<div class="code-sample lang-py" title="callable.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Adder</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

<span class="n">add_3</span> <span class="o">=</span> <span class="n">Adder</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="c1"># create an object that can be called</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">add_3</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>  <span class="c1"># call the object</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add_3(8): </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="callable.out">
<div class="highlight"><pre><span></span><code>add_3(8): 11
</code></pre></div>
</div>
<p>Let&rsquo;s create a class that:</p>
<ol>
<li>
<p>defines a <code>__call__</code> method so that instances can be called like functions;</p>
</li>
<li>
<p>declares the parameters of that method to be <code>*args*</code> and <code>**kwargs</code>
    so that it can be called with any number of regular or keyword arguments;</p>
</li>
<li>
<p>stores those arguments so we can see how the replaced function was called;
    and</p>
</li>
<li>
<p>returns either a fixed value or a value produced by a user-defined function.</p>
</li>
</ol>
<p>The class itself is only 11 lines long:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Fake</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</code></pre></div>
</div>
<p>For convenience,
let&rsquo;s also define a function that replaces some function we&rsquo;ve already defined
with an instance of our <code>Fake</code> class.
This function takes either a fixed value or another function as an argument
and passes those to <code>Fake</code>&lsquo;s constructor:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fixit</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">Fake</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fake</span>
    <span class="k">return</span> <span class="n">fake</span>
</code></pre></div>
</div>
<p>Next,
we define a function that adds two numbers
and write a test for it:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">test_with_real_function</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div>
</div>
<p>We then use <code>fixit</code> to replace the real <code>adder</code> function
with a mock object that always returns 99:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_with_fixed_return_value</span><span class="p">():</span>
    <span class="n">fixit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
</code></pre></div>
</div>
<p>Another test proves that our <code>Fake</code> class records
all of the calls:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_fake_records_calls</span><span class="p">():</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">fixit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="o">.</span><span class="n">calls</span> <span class="o">==</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">{}],</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">{}]]</span>
</code></pre></div>
</div>
<p>And finally,
the user can provide a function to calculate a return value:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_fake_calculates_result</span><span class="p">():</span>
    <span class="n">fixit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">23</span>
</code></pre></div>
</div>
<p>Mock objects are very useful,
but there&rsquo;s a problem with how we&rsquo;re using them.
Every test except the first one replaces <code>adder</code> with a mock object
that does something different.
As a result,
any test that <em>doesn&rsquo;t</em> replace <code>adder</code> will run with
whatever mock object was last put in place
rather than with the original <code>adder</code> function:</p>
<div class="code-sample lang-out" title="mock_object.out">
<div class="highlight"><pre><span></span><code>pass: test_with_real_function
pass: test_with_fixed_return_value
pass: test_fake_records_calls
pass: test_fake_calculates_result
adder(2, 3) is now 23
</code></pre></div>
</div>
<p>We could tell users they have to remember to put everthing back after each test,
but people are forgetful.
Instead,
we can create a <a class="gl-ref" href="../glossary/#context_manager" markdown="1">context manager</a> that does this automatically.
A context manager is a class that defines two methods called <code>__enter__</code> and <code>__exit__</code>.
If the class is called <code>C</code>,
then when Python executes a <code>with</code> block like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="n">C</span><span class="p">(</span><span class="err">…</span><span class="n">args</span><span class="err">…</span><span class="p">)</span> <span class="k">as</span> <span class="n">name</span><span class="p">:</span>
    <span class="err">…</span><span class="n">do</span> <span class="n">things</span><span class="err">…</span>
</code></pre></div>
<p class="continue">it does the following:</p>
<ol>
<li>Call <code>C</code>&lsquo;s constructor with the given arguments.</li>
<li>Assign the result to the variable <code>name</code>.</li>
<li>Call <code>name.__enter__()</code>.</li>
<li>Run the code inside the <code>with</code> block.</li>
<li>Call <code>name.__exit__()</code> when the block finishes.</li>
</ol>
<p class="continue">The last step is guaranteed to happen
even if an exception occurred inside the block
so that the context manager always has a chance to clean up after itself.</p>
<p>Here&rsquo;s a mock object that inherits all the capabilities of <code>Fake</code>
and adds the two methods needed by <code>with</code>:</p>
<div class="code-sample lang-py" title="mock_context.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ContextFake</span><span class="p">(</span><span class="n">Fake</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_traceback</span><span class="p">):</span>
        <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span>
</code></pre></div>
</div>
<p class="continue">And here&rsquo;s a test to prove that it works:</p>
<div class="code-sample lang-py" title="mock_context.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">subber</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">check_no_lasting_effects</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">with</span> <span class="n">ContextFake</span><span class="p">(</span><span class="s2">&quot;subber&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span> <span class="k">as</span> <span class="n">fake</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1234</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fake</span><span class="o">.</span><span class="n">calls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
</div>
<div class="callout">
<h3>Protocols</h3>
<p><code>__enter__</code> and <code>__exit__</code> are an example of a <a class="gl-ref" href="../glossary/#protocol" markdown="1">protocol</a>:
a rule that specifies how programs can provide operations
that Python will execute at specific moments.
Defining an <code>__init__</code> method for a class is another example:
if a class has a method with that name,
Python will call it automatically when constructing a new instance of that class.</p>
</div>
<h2 id="tester-exercises">Section 2.5: Exercises</h2>
<h3 class="exercise">Why a copy?</h3>
<p>Why does the function <code>globals</code> return a copy of the dictionary
containing the program&rsquo;s global variables?
Why doesn&rsquo;t it return the dictionary itself so that programs can modify it?
Why use a function at all instead of simply using a variable called <code>__globals__</code>?</p>
<h3 class="exercise">Counting results</h3>
<ol>
<li>
<p>Modify the test framework so that it reports which tests passed, failed, or had errors
    and also reports a summary of how many tests produced each result.</p>
</li>
<li>
<p>Write unit tests to check that your answer to part 1 works correctly.</p>
</li>
<li>
<p>Think of another plausible way to interpret part 1
    that <em>wouldn&rsquo;t</em> pass the tests you wrote for part 2.</p>
</li>
</ol>
<h3 class="exercise">Literal strings</h3>
<p>If we have defined a variable with the test-skipping marker,
why can&rsquo;t we use that variable as the docstring for several functions like this:</p>
<div class="highlight"><pre><span></span><code><span class="n">TEST_SKIP</span> <span class="o">=</span> <span class="s2">&quot;test:skip&quot;</span>

<span class="k">def</span> <span class="nf">test_sign_negative</span><span class="p">():</span>
    <span class="n">TEST_SKIP</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_sign_positive</span><span class="p">():</span>
    <span class="n">TEST_SKIP</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>
<h3 class="exercise">Failing on purpose</h3>
<p>Putting assertions into code to check that it is behaving correctly
is called <a class="gl-ref" href="../glossary/#defensive_programming" markdown="1">defensive programming</a>;
it&rsquo;s a good practice,
but we should make sure those assertions are failing when they&rsquo;re supposed to,
just as we should test our smoke detectors every once in a while.</p>
<p>Modify the tester so that
if a test function&rsquo;s docstring is <code>"test:assert"</code>,
the test passes if it raises an <code>AssertionErro</code>
and fails if it does not.
Tests whose docstring don&rsquo;t contain <code>"test:assert"</code>
should behave as before.</p>
<h3 class="exercise">Timing tests</h3>
<ol>
<li>
<p>Modify the testing tool so that it records how long it takes to run each test.
    (The function <code>time.time</code> may be useful.)</p>
</li>
<li>
<p>Use Python&rsquo;s own <a href="https://docs.pytest.org/">pytest</a> library to test your implementation.
    (Hint: you may want to replace <code>time.time</code> with a mock object for testing.)</p>
</li>
</ol>
<h3 class="exercise">Timing blocks</h3>
<p>Create a context manager called <code>Timer</code> that reports how long it has been
since a block of code started running:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># your class goes here</span>

<span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">start</span><span class="p">:</span>
    <span class="c1"># ...do some lengthy operation...</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">elapsed</span><span class="p">())</span>  <span class="c1"># time since the start of the block</span>
</code></pre></div>
<h3 class="exercise">Approximately equal</h3>
<ol>
<li>
<p>Write a function <code>assert_approx_equal</code>
    that does nothing if two values are within a certain tolerance of each other
    but throws an exception if they are not:</p>
<pre><code>// throws exception
assert_approx_equal(1.0, 2.0, 0.01, "Values are too far apart")

// does not throw
assert_approx_equal(1.0, 2.0, 10.0, "Large margin of error")
</code></pre>
</li>
<li>
<p>Modify the function so that a default tolerance is used if none is specified:</p>
<pre><code>// throws exception
assert_approx_equal(1.0, 2.0, "Values are too far apart")

// does not throw
assert_approx_equal(1.0, 2.0, "Large margin of error", 10.0)
</code></pre>
</li>
<li>
<p>Modify the function again so that it checks the <a class="gl-ref" href="../glossary/#relative_error" markdown="1">relative error</a>
    instead of the <a class="gl-ref" href="../glossary/#absolute_error" markdown="1">absolute error</a>.
    (The relative error is the absolute value of the difference between the actual and expected value,
    divided by the absolute value.)</p>
</li>
</ol>
<h3 class="exercise">Capturing output</h3>
<ol>
<li>
<p>Read <a href="https://docs.pytest.org/en/6.2.x/capture.html">the documentation</a>
    that explains how to capture <a class="gl-ref" href="../glossary/#stdout" markdown="1">standard output</a>
    when using <a href="https://docs.pytest.org/">pytest</a>.</p>
</li>
<li>
<p>Modify this chapter&rsquo;s testing tool so that
    users can check what a function prints to standard output
    as part of a unit test.</p>
</li>
</ol>
<h3 class="exercise">Selecting tests</h3>
<p>Modify the testing tool so that if a user provides <code>-s pattern</code> or <code>--select pattern</code>
then it only runs tests that contain the string <code>pattern</code> in their name.</p>
<h3 class="exercise">Setup and teardown</h3>
<p>Testing frameworks often allow programmers to specify a <code>setup</code> function
that is to be run before each test
and a corresponding <code>teardown</code> function
that is to be run after each test.
(<code>setup</code> usually re-creates complicated test fixtures,
while <code>teardown</code> functions are sometimes needed to clean up after tests,
e.g., to close database connections or delete temporary files.)</p>
<p>Modify the testing tool in this chapter so that
if a file of tests contains a function called <code>setup</code>
then the tool calls it exactly once before running each test in the file.
Add a similar way to register a teardown function.</p>
	  
        </main>
      </div>
    </div>
  </body>
</html>
